{
  "taskName": "JSON Field Validator Implementation",
  "creationDate": "2025-07-17",
  "priority": "High",
  "estimatedEffort": "Medium",
  "description": "Implement a flexible, extensible JSON field validation system that enhances the existing Schema Compliance Validator with field-specific validation and correction suggestions.",
  "background": "The current Schema Compliance Validator provides basic validation against a JSON schema, but lacks the ability to provide field-specific validation rules and correction suggestions. We need to enhance this system to handle specific field validations (like stepName) and provide intelligent fix suggestions.",
  "requirements": [
    {
      "id": "REQ-1",
      "description": "Create a class injection approach for field validators to keep the main validator code clean and maintainable",
      "details": "Implement a FieldValidator interface and registry system that allows for pluggable field validators"
    },
    {
      "id": "REQ-2",
      "description": "Implement a StepNameValidator that validates and suggests corrections for step names",
      "details": "The validator should check step name format, suggest corrections for invalid names, and show further validation issues that would occur after fixing"
    },
    {
      "id": "REQ-3",
      "description": "Create a general string correction utility for field validation",
      "details": "Implement a utility that can suggest corrections for string fields based on pattern requirements"
    },
    {
      "id": "REQ-4",
      "description": "Integrate field validators with the existing SchemaComplianceValidator",
      "details": "Modify the SchemaComplianceValidator to use the field validator registry"
    },
    {
      "id": "REQ-5",
      "description": "Support configurable recursion depth for fix suggestions",
      "details": "Allow configuration of how deep the validation system should go when suggesting fixes and showing further validation issues"
    },
    {
      "id": "REQ-6",
      "description": "Implement a prioritization system for field validators",
      "details": "Allow field validators to specify their priority to control the order of validation and fix suggestions"
    }
  ],
  "implementationApproach": {
    "architecture": {
      "components": [
        {
          "name": "FieldValidator Interface",
          "description": "Define an interface for field validators with methods for validation, handling specific validatable objects, and priority",
          "codeExample": "public interface FieldValidator<T extends PipelineConfigValidatable> {\n    List<String> validate(T validatable, Set<ValidationMessage> errors, int currentDepth);\n    boolean canHandle(PipelineConfigValidatable validatable);\n    int getPriority();\n}"
        },
        {
          "name": "FieldValidatorRegistry",
          "description": "Create a registry that collects and manages all field validators, sorting them by priority",
          "codeExample": "public class FieldValidatorRegistry {\n    private final List<FieldValidator<?>> validators;\n    \n    public FieldValidatorRegistry(List<FieldValidator<?>> validators) {\n        this.validators = validators.stream()\n            .sorted(Comparator.comparing(FieldValidator::getPriority).reversed())\n            .collect(Collectors.toList());\n    }\n    \n    public List<FieldValidator<?>> getValidatorsFor(PipelineConfigValidatable validatable) {\n        return validators.stream()\n            .filter(validator -> validator.canHandle(validatable))\n            .collect(Collectors.toList());\n    }\n}"
        },
        {
          "name": "SchemaComplianceValidator Integration",
          "description": "Modify the SchemaComplianceValidator to use the FieldValidatorRegistry",
          "codeExample": "public class SchemaComplianceValidator implements PipelineConfigValidator {\n    private final JsonSchema schema;\n    private final ObjectMapper objectMapper;\n    private final int maxRecursionDepth;\n    private final FieldValidatorRegistry validatorRegistry;\n    \n    // Constructor and other methods...\n    \n    private List<String> suggestFixes(PipelineConfigValidatable validatable, Set<ValidationMessage> errors, int currentDepth) {\n        // Stop recursion if we've reached the maximum depth\n        if (currentDepth >= maxRecursionDepth) {\n            return Collections.singletonList(\"Maximum recursion depth reached. Some additional issues may not be shown.\");\n        }\n        \n        // Get all applicable validators and collect their suggestions\n        List<String> allSuggestions = new ArrayList<>();\n        for (FieldValidator<?> validator : validatorRegistry.getValidatorsFor(validatable)) {\n            // Apply validator and collect suggestions\n        }\n        \n        return allSuggestions;\n    }\n}"
        }
      ]
    },
    "specificValidators": [
      {
        "name": "ClusterValidator",
        "description": "Validates and suggests fixes for missing cluster configurations",
        "codeExample": "public class ClusterValidator implements FieldValidator<PipelineConfig> {\n    @Override\n    public List<String> validate(PipelineConfig config, Set<ValidationMessage> errors, int currentDepth) {\n        List<String> suggestions = new ArrayList<>();\n        \n        // Check if any errors are related to missing cluster\n        boolean missingCluster = errors.stream()\n                .anyMatch(error -> error.getMessage().contains(\"cluster\"));\n                \n        if (missingCluster) {\n            suggestions.add(\"- Add a default cluster using 'createSimpleClusterOnlySetup()' method\");\n            \n            // Simulate validation with a default cluster\n            // ... implementation details\n        }\n        \n        return suggestions;\n    }\n    \n    @Override\n    public boolean canHandle(PipelineConfigValidatable validatable) {\n        return validatable instanceof PipelineConfig;\n    }\n    \n    @Override\n    public int getPriority() {\n        return 100; // High priority\n    }\n}"
      },
      {
        "name": "StepNameValidator",
        "description": "Validates and suggests fixes for step name format issues",
        "codeExample": "public class StepNameValidator implements FieldValidator<PipelineConfig> {\n    private static final Pattern STEP_NAME_PATTERN = Pattern.compile(\"^[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9]$\");\n    \n    @Override\n    public List<String> validate(PipelineConfig config, Set<ValidationMessage> errors, int currentDepth) {\n        List<String> suggestions = new ArrayList<>();\n        \n        // Check for stepName issues in each step\n        if (config.pipelineSteps() != null) {\n            for (Map.Entry<String, PipelineStepConfig> entry : config.pipelineSteps().entrySet()) {\n                String stepId = entry.getKey();\n                PipelineStepConfig step = entry.getValue();\n                \n                // Check if stepName matches the key in the map\n                if (!stepId.equals(step.stepName())) {\n                    suggestions.add(\"- Step ID '\" + stepId + \"' should match stepName '\" + step.stepName() + \"'\");\n                }\n                \n                // Check for stepName format issues\n                if (step.stepName() != null && !STEP_NAME_PATTERN.matcher(step.stepName()).matches()) {\n                    String fixedStepName = StringCorrectionUtil.suggestCorrection(step.stepName(), STEP_NAME_PATTERN, \"step\");\n                    suggestions.add(\"- Step name '\" + step.stepName() + \"' doesn't match required pattern. Suggested fix: '\" + fixedStepName + \"'\");\n                    \n                    // Simulate validation with fixed stepName\n                    // ... implementation details\n                }\n            }\n        }\n        \n        return suggestions;\n    }\n    \n    @Override\n    public boolean canHandle(PipelineConfigValidatable validatable) {\n        return validatable instanceof PipelineConfig;\n    }\n    \n    @Override\n    public int getPriority() {\n        return 90; // Lower than cluster validator\n    }\n}"
      },
      {
        "name": "StringCorrectionUtil",
        "description": "Utility for suggesting corrections to string fields based on pattern requirements",
        "codeExample": "public class StringCorrectionUtil {\n    /**\n     * Suggests a corrected version of a string based on a pattern\n     */\n    public static String suggestCorrection(String original, Pattern pattern, String fieldName) {\n        if (original == null || original.isEmpty()) {\n            return fieldName + \"-default\";\n        }\n        \n        // Remove invalid characters based on pattern\n        String patternStr = pattern.pattern();\n        String charClass = patternStr.substring(patternStr.indexOf(\"[\"), patternStr.lastIndexOf(\"]\") + 1);\n        String negatedClass = charClass.startsWith(\"[^\") ? charClass : \"[^\" + charClass.substring(1);\n        \n        String fixed = original.replaceAll(negatedClass, \"\");\n        \n        // Handle edge cases (empty string, starting/ending chars)\n        if (fixed.isEmpty()) {\n            return fieldName + \"-default\";\n        }\n        \n        // Add prefix/suffix if needed based on pattern\n        if (patternStr.startsWith(\"^[a-zA-Z\") && !Character.isLetterOrDigit(fixed.charAt(0))) {\n            fixed = \"a\" + fixed;\n        }\n        \n        if (patternStr.endsWith(\"[a-zA-Z0-9]$\") && !Character.isLetterOrDigit(fixed.charAt(fixed.length() - 1))) {\n            fixed = fixed + \"1\";\n        }\n        \n        return fixed;\n    }\n}"
      }
    ]
  },
  "testingStrategy": {
    "unitTests": [
      "Test each field validator in isolation with various input scenarios",
      "Test the FieldValidatorRegistry with mock validators",
      "Test the StringCorrectionUtil with various patterns and input strings",
      "Test the SchemaComplianceValidator integration with mock field validators"
    ],
    "integrationTests": [
      "Test the complete validation system with valid and invalid pipeline configurations",
      "Test with different recursion depths to ensure proper behavior",
      "Test with multiple field validators to ensure proper prioritization",
      "Test with real-world pipeline configurations to ensure practical usefulness"
    ],
    "testCases": [
      {
        "name": "Valid Pipeline Configuration",
        "description": "Test with a valid pipeline configuration to ensure it passes validation",
        "expectedResult": "Validation should succeed with no errors or suggestions"
      },
      {
        "name": "Invalid Step Name",
        "description": "Test with a pipeline containing an invalid step name",
        "expectedResult": "Validation should fail with specific error messages about the step name and suggest a corrected name"
      },
      {
        "name": "Missing Cluster",
        "description": "Test with a pipeline missing a cluster configuration",
        "expectedResult": "Validation should fail with specific error messages about the missing cluster and suggest adding a default cluster"
      },
      {
        "name": "Multiple Validation Issues",
        "description": "Test with a pipeline containing multiple validation issues",
        "expectedResult": "Validation should fail with specific error messages for each issue and suggest fixes in priority order"
      },
      {
        "name": "Recursion Depth Limits",
        "description": "Test with different recursion depth limits to ensure proper behavior",
        "expectedResult": "Validation should respect the recursion depth limit and provide appropriate messages"
      }
    ]
  },
  "acceptanceCriteria": [
    "The field validator system is implemented with a clean, extensible architecture",
    "The StepNameValidator correctly validates step names and suggests corrections",
    "The StringCorrectionUtil correctly suggests corrections for string fields",
    "The SchemaComplianceValidator correctly integrates with the field validator system",
    "The system respects the configurable recursion depth",
    "The system prioritizes validators correctly",
    "All tests pass with the enhanced validation system"
  ],
  "implementationNotes": [
    "Use dependency injection (CDI) for managing field validators",
    "Ensure backward compatibility with existing code",
    "Keep the validation system performant by limiting recursion depth",
    "Provide clear, actionable error messages and suggestions",
    "Design for extensibility to easily add new field validators in the future",
    "Consider adding a builder pattern for the SchemaComplianceValidator to make configuration more flexible"
  ],
  "relatedTasks": [
    "Schema Compliance Validator Enhancement (fixer-upper.md)"
  ]
}